# OOP핵심개념

## Python에서의 생성자

- **init**으로 만들어진다.
- 딴 곳에서는 this 쓰지만, 파이썬에서는 self를 사용한다.
- 파이썬에는 Private, public같은 것 없고, 타입도 없다.
- \*\*모든 메서드는 첫번째 인자로 self를 받는다.(무조건)
- 파이썬에서 문자열 안에 인자 넣으려면 {} 쓰면 된다.
  - print(f"hello my name is {self.name} ")
  - 앞에 f 작성해줘야된다.

## 파이썬에서 상속

- 다른 곳에서의 상속과 비슷하게 작동한다.
- 파이썬에서의 상속은 클래스 파라미터에 상속받을 클래스를 넣으면 된다.
  - Class Player(Human) : Human 클래스를 Player에 상속하겠다는 의미
- 생성자 간의 관계를 잘 살펴야된다.
  - Human이라는 곳에서 Name을 정의하는 상황, 다른 상속받은 녀석들은 Name을 안 다뤄주면 -> 에러난다
  - 이런 문제를 해결하기 위해서 super 함수를 사용해야된다.
  - **init** 안에 super().**init**()을 사용함으로써, 부모 클래스의 생성자를 작동시킨다.
  - 이 안에 부모객체가 가져야되는 인자들을 넘겨주면 된다. super().**init**(name)
  - 이렇게 함으로써, 부모 클래스의 생성자를 작동시킬 수 있다.
- 결국 상속자를 다 돌려야되는 것은 동일하다.
- 그리고, 부모상속자에 필요한 내용은 super()로 사용하면된다.
  - super()는 부모객체를 작동시키는 녀석이라고 생각하면 된다.
  - 부모객체에 있는 것들을 쓰고싶을 때 언제든 사용할 수 있다.

## 상속받은 것들을 오버라이딩하고 싶을 때

- 오버라이딩은 그냥, 바로 하위 클래스에서 작성하면 바로 적용된다.
  - 간단한 오버라이딩 가능
  - 클래스를 확장할 때 자주 사용할 수 있다.

## **str**와 같은 \_\_ 메소드들(UnderScore Method)

- **str**은 객체를 바로 문자열로 보려고할 때 사용하는 메소드이다.
  - 이 녀석을 쓰면 이 객체의 주소값을 리턴한다.
  - 하지만, 오버라이딩하면 객체를 프린트할 때 지정한 값을 리턴하는 것으로 바뀐다.
  - print(f""), f빼면 프린트f처럼 작동 안한다.
  - 이런 \_\_ \_\_ 메소드들을 내부적으로 작동하는 파이썬이라고 칭한다.
- **str**는 클래스를 문자열로써 어떻게 표현할지 정한다고 생각하면 된다.
- \_\_ \_\_ 함수들을 찾는 방법은?
  - print(dir(instance)) 통해서 알 수 있다.
  - 이렇게 하면, 그 클래스 안에서 작동하고 있는 메소드들을 볼 수 있게 해준다.
- print(a.name)을 하면, 내부적으로는 **getattribute**(self,name)을 작동시킨다.
  - 따라서 이런 것들도 오버라이딩하면, 의도한 바와 다르게 작동할 수 있다.
  - 사용하는 코드들이 다 내부적인 메소드로 구성되었다는 것을 아는게 좋다.
  - 이런식으로 특정 클래스는 속성에 접근하지 못하게 할 수도 있다
    - 접근하는 것들을 오버라이딩함으로써!

# 장고 사용 방법

## DB조작 방법

- Migration을 통해서, DB를 조작할 수 있다.
- Migration은 DB를 조작하기 위해 만들어 둔 모듈이라고 생각하면 된다.
- Migration은 DB의 State를 조작한다는 것만 기억하자
- python3 manage.py migrate로 작동한다.
- 나중에는 자신만의 migrationFile을 만들거 migrate하게 될 것이다.

## 장고 기능

- 비밀번호 체크 알아서 해준다 개쩔어!
- 동적으로 자동 작동함
- 유저 인증도 알아서 해준다 개쩔어!
- 슈퍼 유저 만드는 방법 Python3 manage.py createsuperuser

## 라이브러리와 프레임워크의 차이점

- 프레임워크는 다 변수같은 것들의 위치가 지정되어있다.
- 그렇기 때문에 그걸 건드리는 방법으로만 수정이 가능하다.
- 지정된 변수를 기반으로 내가 작동하는 서버를 변경해낸다.
- url들을 설정하고 싶으면, urls.py를 사용하면 된다.
- 프레임 워크는 시작되었을 때 바로 Settings.py를 보고 url치면 urls.py를 쳐다본다.
- 우리는 장고를 불러다 쓰는게 아니라, 장고의 집 안에 있기 때문에 그 녀석이 하라는대로 해야된다.

## 장고의 App들

- 폴더에 데이터와 로직이 있다고 생각해봐라, 그게 App이다
- 장고App은 데이터와 로직을 넣고 캡슐화를 해버린다.
- 그렇기 때문에 그 App들(Class라고 생각하자)을 어떻게 구분할지 고민하는 것이 좋다.
- 필요한 데이터와 로직이 다르다면 이 모듈들을 분리해내야된다.
-
