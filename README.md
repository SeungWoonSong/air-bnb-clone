# OOP핵심개념

## Python에서의 생성자

- **init**으로 만들어진다.
- 딴 곳에서는 this 쓰지만, 파이썬에서는 self를 사용한다.
- 파이썬에는 Private, public같은 것 없고, 타입도 없다.
- \*\*모든 메서드는 첫번째 인자로 self를 받는다.(무조건)
- 파이썬에서 문자열 안에 인자 넣으려면 {} 쓰면 된다.
  - print(f"hello my name is {self.name} ")
  - 앞에 f 작성해줘야된다.

## 파이썬에서 상속

- 다른 곳에서의 상속과 비슷하게 작동한다.
- 파이썬에서의 상속은 클래스 파라미터에 상속받을 클래스를 넣으면 된다.
  - Class Player(Human) : Human 클래스를 Player에 상속하겠다는 의미
- 생성자 간의 관계를 잘 살펴야된다.
  - Human이라는 곳에서 Name을 정의하는 상황, 다른 상속받은 녀석들은 Name을 안 다뤄주면 -> 에러난다
  - 이런 문제를 해결하기 위해서 super 함수를 사용해야된다.
  - **init** 안에 super().**init**()을 사용함으로써, 부모 클래스의 생성자를 작동시킨다.
  - 이 안에 부모객체가 가져야되는 인자들을 넘겨주면 된다. super().**init**(name)
  - 이렇게 함으로써, 부모 클래스의 생성자를 작동시킬 수 있다.
- 결국 상속자를 다 돌려야되는 것은 동일하다.
- 그리고, 부모상속자에 필요한 내용은 super()로 사용하면된다.
  - super()는 부모객체를 작동시키는 녀석이라고 생각하면 된다.
  - 부모객체에 있는 것들을 쓰고싶을 때 언제든 사용할 수 있다.

## 상속받은 것들을 오버라이딩하고 싶을 때

- 오버라이딩은 그냥, 바로 하위 클래스에서 작성하면 바로 적용된다.
  - 간단한 오버라이딩 가능
  - 클래스를 확장할 때 자주 사용할 수 있다.

## **str**와 같은 \_\_ 메소드들(UnderScore Method)

- **str**은 객체를 바로 문자열로 보려고할 때 사용하는 메소드이다.
  - 이 녀석을 쓰면 이 객체의 주소값을 리턴한다.
  - 하지만, 오버라이딩하면 객체를 프린트할 때 지정한 값을 리턴하는 것으로 바뀐다.
  - print(f""), f빼면 프린트f처럼 작동 안한다.
  - 이런 \_\_ \_\_ 메소드들을 내부적으로 작동하는 파이썬이라고 칭한다.
- **str**는 클래스를 문자열로써 어떻게 표현할지 정한다고 생각하면 된다.
- \_\_ \_\_ 함수들을 찾는 방법은?
  - print(dir(instance)) 통해서 알 수 있다.
  - 이렇게 하면, 그 클래스 안에서 작동하고 있는 메소드들을 볼 수 있게 해준다.
- print(a.name)을 하면, 내부적으로는 **getattribute**(self,name)을 작동시킨다.
  - 따라서 이런 것들도 오버라이딩하면, 의도한 바와 다르게 작동할 수 있다.
  - 사용하는 코드들이 다 내부적인 메소드로 구성되었다는 것을 아는게 좋다.
  - 이런식으로 특정 클래스는 속성에 접근하지 못하게 할 수도 있다
    - 접근하는 것들을 오버라이딩함으로써!

# 장고 사용 방법

## DB조작 방법

- Migration을 통해서, DB를 조작할 수 있다.
- Migration은 DB를 조작하기 위해 만들어 둔 모듈이라고 생각하면 된다.
- Migration은 DB의 State를 조작한다는 것만 기억하자
- python3 manage.py migrate로 작동한다.
- 나중에는 자신만의 migrationFile을 만들거 migrate하게 될 것이다.

## 장고 기능

- 비밀번호 체크 알아서 해준다 개쩔어!
- 동적으로 자동 작동함
- 유저 인증도 알아서 해준다 개쩔어!
- 슈퍼 유저 만드는 방법 Python3 manage.py createsuperuser

## 라이브러리와 프레임워크의 차이점

- 프레임워크는 다 변수같은 것들의 위치가 지정되어있다.
- 그렇기 때문에 그걸 건드리는 방법으로만 수정이 가능하다.
- 지정된 변수를 기반으로 내가 작동하는 서버를 변경해낸다.
- url들을 설정하고 싶으면, urls.py를 사용하면 된다.
- 프레임 워크는 시작되었을 때 바로 Settings.py를 보고 url치면 urls.py를 쳐다본다.
- 우리는 장고를 불러다 쓰는게 아니라, 장고의 집 안에 있기 때문에 그 녀석이 하라는대로 해야된다.

## 장고의 App들

- 폴더에 데이터와 로직이 있다고 생각해봐라, 그게 App이다
- 장고App은 데이터와 로직을 넣고 캡슐화를 해버린다.
- 그렇기 때문에 그 App들(Class라고 생각하자)을 어떻게 구분할지 고민하는 것이 좋다.
- 필요한 데이터와 로직이 다르다면 이 모듈들을 분리해내야된다.

## APP 시작하기

- APP 만드는 명령어는 python manage.py startapp (이름)
- models.py 통해서 모델을 만들고 admin.py에 등록하면 된다.
- houses APP을 만들 때, 무엇이 필요한지(데이터)를 정해야된다.
- 모델.py를 통해서, 우리는 SQL을 안써도 된다. 장고가 알아서 해준다.
- typeORM같은 느낌으로 모델을 정해주면 된다.
- 장고가 이 데이터의 모형을 알게 된다면, 이것을 통해 어드민 페이지도 알아서 만들어준다! 개쩔어
- App을 쓰기 위해서는 settings.py에 등록해주는걸 잊지말자!

## APP 등록하기

- @을 통해, 이 HouseAdmin이 House클래스를 조작한다는 것을 선언한다.
  @admin.register(House)
  class HouseAdmin(admin.ModelAdmin):
  pass
- admin.py을 통해, 내가 만들 Class를 등록할 수 있다.
- Model을 만들었으면 migration해줘야된다 그렇게 함으로써 데이터베이스 형태 만들 수 있다.
- python manage.py makemigrations -> migrate
- Model만들기 -> 어드민에 등록 -> 마이그레이션 만들기 -> 마이그레이트
- 이렇게만 해도, 바로 만들 수 있다 개쩔어..
- 단 몇줄만으로, 어드민 패널을 만들 수 있다.

### 정리

- Models.py -> 내 앱의 모델을 작성한다(데이터의 모형)
  - 이를 통해, 장고가 알아서 데이터베이스의 모형을 바꿀 수 있게 된다.
  - CHAR인지 INT인지 여기에 작성하면 됨
  - 우리는 파이썬으로 쓰지만, 알아서 SQL로 해준다.
- admin.py에 모델을 등록하기만 해도, 장고가 admin패널을 통째로 만들어준다.
  - 삭제 관리, 검색 다 되는 녀석을 알아서 만들어준다.
  - 내가 정의한 데이터형식에 맞춰서 알아서 작동한다.
- 이렇게 만들기만 하면 Sync가 안된다(데이터베이스와 장고 간)
  - 이럴 때를 위해 sync기능이 있는 것이다.
  - makemigration을 치면, 이제 sync를 위한 준비를하고
  - migrate하면, 이제 싱크가 되는 것이다.
- model을 수정하고 싶으면, model을 교체하면 수정된다.
  - 개쩔어..
  - 동일하게 makemigrations -> migrate하면 된다.

## Admin 패널에서 할 수 있는 일들

- 장고가 프레임워크인 것을 기억하자(로직을 짜는 것이 아닌 알맞게 프레임워크를 사용하는 것)
  - 그러면 알아서 나머지 것들을 해결해준다.
- 초기 상태에서, 모델을 만들면 어드민에 이름이 이상하게 나온다. House object(1)이런 식으로..
  - 이걸 예쁘게 고쳐보자
  - **str**을 이용, 고칠 수 있다.
  - 이 데이터들도 하나하나 Class의 Instance라고 할 수 있다.
  - 즉, 지금 저렇게 House object(1)이라고 나오는 것은 **str** 가 그렇게 정의하고 있기 때문
  - 그렇다면 이 것을 고쳐서 문제를 해결할 수 있다.
- 이렇게 함으로써, 즉시 설정이 된다.
- House를 그냥 덩그러니 만들면, 그 녀석이 가져야되는 것들이 밖에서 안보인다.
  - 즉, 유저 같은 경우 밖에서 이 사람 성, 이메일 등등이 보이는데 HOUSE는 빈칸임
  - 이것은 우리가 pass를 하기 때문이다
  - admin.py를 수정함으로써 바꿀 수 있다! column을 만들 수 있다.
- admin.py에 있는 곳에 가서, list_display를 만들면 된다.
  - 거기에 있는 리스트에 어떤 것들을 표시할지 씀으로써, Column만들 수 있다.
  - 놀랍게도 filter도 만들 수 있다!(list_filter)
  - 한줄로 모든 것들이 작동한다.. 엄청나!
- 검색조차도 가능해진다!
  - 어떤 것을 기준으로 검색할지 작성하면 그것을 인덱싱하고
  - 심지어 address\_\_startswith을 작성하면, 이것으로 시작하는 걸로만 할 수도 있다.
  - 진짜 대단해! endswith이런 것들도 가능하다 대단해..
- 리스트는 일반적으로 많이 사용되지 않는다.
  - 되도록이면 튜플로 이용한다.
  - 튜플 1개면, 알아서 string으로 만들어버린다.
  - 그렇기 때문에 튜플이 1개면 뒤에 , 붙여줘야된다. 끝
- 나중에 admin 패널에서 다른 모델간에 상관 관계도 작성할 수 있다.
  - User가 가지고 있는 집의 수 혹은 평균 평점 등등

## 장고 Document 잘 쓰는 법

- https://docs.djangoproject.com/en/4.1/ref/models/fields/
- 모든 내용들은 다 장고 자료에 등록되어있다.
- 잘 보고 잘 쓰면 된다!
  - verbose_name 이런 Field를 작성하면, 이제 내가 보고있는 데이터 형식 이름과
  - 사람들이 보는 내용들을 다르게 만들 수 있다!
  - help_text같은 것들도 사용해서 사람들에게 보이게 할 수 있다.
- 이 공식문서들을 잘 보고 이용하는 것이 중요하다.
- 결국 장고를 잘 쓰는 것은 이것을 잘 읽는 것이다.

# User App

## 유저의 모델은 어떻게 해야되는가?

- 앱을 만들면, 그에 맞춰서 권한들이 생긴다.
- 이 유저 어플을 수정하려면 어떻게 해야되는가?
  - 다 좋은데 유저에 예를들어, 프로필 사진을 추가하고 싶다거나 하면 어떻게 해야하는가?
- 확장하는 2가지 방법
  - 첫번째, 유저는 그대로 두고, Profile이라는 모델을 따로 만들어서 2개의 모델을 사용하는 것
  - 두번째, 커스텀된 유저를 만들고 기존 유저를 대체하기
  - 우리는 두번째 방법을 이용한다.
- 첫번쨰 환경으로 하면, 나중에 유저모델 수정이 매우매우 어려워진다.
  - 그렇기 때문에 2번 방법을 추천한다.
  - 처음 프로젝트를 시작할 때 바로 하는 것이 좋다.
- 그래서 장고를 처음 시작하면 유저 모델부터 교체해버린다.

## 직접 유저 만드는 법
- 일단 기본적으로는 기본 유저로 설정되어있다.
- 따라서, user라는 모델을 만들고, 기본 유저를 Impor한다
- 이후, setting.py로 들어가서, 유저 모델을 기본이 아닌 새로 만든 것으로 바꾼다.
  - AUTH_USER_MODEL -> 세부사항 장고 document참조
- 이 상태에서 migrate하면, 이전에 있는 데이터 때문에 에러 뜬다.
- 